using UnityEngine;
using System.Collections;

public class way_projector : MonoBehaviour {


	//neues material erstellen
	//neue alpha text erstellen
	//neue final text erstellen
	//final_text dem mat zuweisen

	//auf änderungen prüfen
	//neue alpha erstellen -> von vS nach vE mit brush
	//alpha+way_text verrrechnen 


//	private Projector text_proj;
//	private Material  projector_material;

//	private Texture2D final_text;



	// Use this for initialization
	void Start () {
	//	if(GameObject.Find(vars.walk_way_manager_name).GetComponent<walk_way_manager>().enable_drawing){
		/*

		final_text = new Texture2D(1024,1024);
		clear_brushed_path(); // clear the texture...
		text_proj = this.gameObject.GetComponent<Projector>();


		//setup mat
		projector_material = new Material(Shader.Find("Transparent/Diffuse")); //we nee an akpha channel so we must use a transparent shader
		projector_material.mainTexture = final_text; //assign the texture to the main_texture of the material
		projector_material.mainTextureScale = new Vector2(1.0f, 1.0f); // the lining must be 1|1 !!!!!
		//assin mat to projecotr
		text_proj.material = projector_material; // assign the new material to the projector

	//	}
*/
	}


	//clear()
	public void clear_brushed_path(){
		//final_text = GameObject.Find(vars.walk_way_manager_name).GetComponent<walk_way_manager>().get_init_text();

	}

	public void draw_path(Vector3 pos){
	/*
		int x = 0;
		int y = 0;

		RaycastHit hit;
		if (Physics.Raycast(pos, -Vector3.up, out hit, 100.0F)){
			//Debug.Log(hit.collider.name);
		
			x = (int)(hit.textureCoord.x * final_text.width);
			y = (int)(hit.textureCoord.y * final_text.height);



			//je nach laufrichtung noch anpassen
			x -=10; // die correction damit die ameise genua auf dm brush läuft

			for (int k = 0; k < GameObject.Find(vars.walk_way_manager_name).GetComponent<walk_way_manager>().brush_texture.width; k++) {
				for (int l = 0; l < GameObject.Find(vars.walk_way_manager_name).GetComponent<walk_way_manager>().brush_texture.height; l++) {
				

				
				if((l+y) < 0 || (k+x) < 0 || (l+y) >= final_text.width || (l+y) >= final_text.height){

					//schauen ob da doch was ist und das nicht mit dem brus überschreiben

				}else{
						float t = GameObject.Find(vars.walk_way_manager_name).GetComponent<walk_way_manager>().brush_texture.GetPixel(k,l).r*GameObject.Find(vars.walk_way_manager_name).GetComponent<walk_way_manager>().max_trans;
						if(t < final_text.GetPixel(k+x,l+y).a){
							t = final_text.GetPixel(k+x,l+y).a;
						}
						
						final_text.SetPixel(k+x,l+y, new Color(final_text.GetPixel(k+x,l+y).r, final_text.GetPixel(k+x,l+y).g, final_text.GetPixel(k,l).b,t));



				}


				//brushdraufrechnen

			}
		}	
		
		final_text.Apply();
		}//ende raycast
	*/
	}
	// Update is called once per frame
	void Update () {
	
	}
}
